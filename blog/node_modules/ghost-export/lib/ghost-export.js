var dateFormat = require('dateformat'),
    fs = require('fs'),
    path = require('path'),
    sqlite3 = require('sqlite3');

module.exports = function(args, callback) {
  callback = callback || function() {};
  if (args.published === undefined) { args.published = true; }

  if (!args.source) {
    callback(new Error('No source Ghost app specified'), 0);
  } else if (!fs.existsSync(args.source)) {
    callback(new Error('Source app does not exist'), 0);
  } else if (!args.destination) {
    callback(new Error('No destination directory specified'), 0);
  } else {
    if (!fs.existsSync(args.destination)) { fs.mkdirSync(args.destination); }

    if (args.published && !args.drafts) {
      var where = ' WHERE status IS NOT "draft"';
    } else if (!args.published && args.drafts) {
      var where = ' WHERE status IS "draft"';
    } else { var where = ''; }

    var dbfile = ( args.dev ) ? 'ghost-dev.db' : 'ghost.db';
    var db = new sqlite3.Database(path.join(args.source, 'content/data/' + dbfile), function(err, db) {
      if (err) callback(err, 0);
    });

    // take the posts object and make a file out of it
    var handlePostsRow = function(err, row, subfolder) {
      var prefix;
      if (row.status === 'draft') {
        prefix = 'draft-'
      } else {
        prefix = 'published-' + dateFormat(new Date(row.published_at), 'yyyy-mm-dd-');
      }
      var name = prefix + row.slug + '.md';
      var outFile = path.join(subfolder, name);

      var intro = '# ' + row.title + '\n';
      try {
        fs.writeFileSync(outFile, intro + row.markdown);
      } catch(err) {
        callback(err, 0);
      }

    }

    // handling subfolders for tags
    if( args.tags )
    {
      var tags = args.tags.split(',');
      for(var i=0; i<tags.length; i++)
      {
        var tagFolder = '/' + tags[i];
        if (!fs.existsSync(path.join(args.destination, tags[i]))) {
          console.log(' making directory ' + path.join(args.destination, tags[i]));
          fs.mkdirSync(path.join(args.destination, tags[i]));
        }
        // check each tag
        db.serialize(function() {
          db.each('SELECT posts.*, tags.name FROM posts \
            JOIN posts_tags ON (posts.id == posts_tags.post_id) \
            JOIN tags ON (posts_tags.tag_id = tags.id) \
            WHERE tags.name == "' + tags[i] + '"'
              , function(err, row) {
              handlePostsRow(err, row, path.join(args.destination, row.name ) );
          }, function(err, count) {
            callback(err, count);
          });
        });
      }
      // check for posts without these tags
      var tagslist = '("' + args.tags.replace(',', '","') + '")';
      db.serialize(function() {
        db.each('SELECT posts.* FROM posts \
          WHERE NOT EXISTS (SELECT 1 FROM posts_tags \
          JOIN tags ON (posts_tags.tag_id = tags.id) \
          WHERE posts_tags.post_id == posts.id \
          AND tags.name IN ' + tagslist + ')'
            , function(err, row) {
            console.log(row.title);
            handlePostsRow(err, row, args.destination);
        }, function(err, count) {
          callback(err, count);
        });
      });


    }
    else
    {
      // normal function, throw everything into the destination folder
      db.serialize(function() {
        db.each('SELECT * FROM posts' + where, function(err, row) {
          handlePostsRow(err, row);
        }, function(err, count) {
          callback(err, count);
        });
      });

      db.close();
    }
  }
};
